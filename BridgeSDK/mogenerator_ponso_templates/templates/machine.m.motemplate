//
//  <$generatedObjectClassName$>.m
//
//  $Id$
//
// DO NOT EDIT. This file is machine-generated and constantly overwritten.
// Make changes to <$generatedObjectClassName$>.h instead.
//

#import "_<$generatedObjectClassName$>.h"<$if needsInternalHeader$>
#import "_<$generatedObjectClassName$>Internal.h"<$endif$>
#import "ModelObjectInternal.h"
#import "NSDate+SBBAdditions.h"
<$if userInfo.encrypted$>
#import "RNEncryptor.h"
#import "RNDecryptor.h"
<$endif$>

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>#import "<$Relationship.destinationEntity.generatedObjectClassName$>.h"
<$endif$><$endforeach do$>

@interface _<$generatedObjectClassName$>()
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if Relationship.isToMany$>@property (nonatomic, strong, readwrite) NSArray *<$Relationship.name$>;
<$endif$><$endif$><$endforeach do$>
@end

// see xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/602958/documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html
@interface NSManagedObject (<$name$>)
<$foreach Attribute noninheritedAttributes do$>
<$if TemplateVar.arc$>
<$if Attribute.hasDefinedAttributeType$>@property (nonatomic, strong) <$Attribute.objectAttributeType$> <$Attribute.name$>;<$endif$>
<$else$>
<$if Attribute.hasDefinedAttributeType$>@property (nonatomic, retain) <$Attribute.objectAttributeType$> <$Attribute.name$>;<$endif$>
<$endif$>
<$if Attribute.hasScalarAttributeType$>@property (nonatomic, assign) <$Attribute.scalarAttributeType$> <$Attribute.name$>Value;<$endif$>
<$endforeach do$>
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
<$if Relationship.isToMany$>
<$if TemplateVar.arc$>
@property (nonatomic, strong, readonly) NSArray *<$Relationship.name$>;
<$else$>
@property (nonatomic, retain, readonly) NSArray *<$Relationship.name$>;
<$endif$>
<$else$>
<$if Relationship.isTransient $>@property (nonatomic, assign, readwrite) NSManagedObject *<$Relationship.name$>;
<$else$>
<$if TemplateVar.arc$>
@property (nonatomic, strong, readwrite) NSManagedObject *<$Relationship.name$>;
<$else$>
@property (nonatomic, retain, readwrite) <NSManagedObject *<$Relationship.name$>;
<$endif$>
<$endif$>
<$endif$><$endif$><$endforeach do$>
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
<$if Relationship.isToMany$>- (void)add<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value_ settingInverse: (BOOL) setInverse;
- (void)add<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value_;
- (void)remove<$Relationship.name.initialCapitalString$>Objects;
- (void)remove<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value_ settingInverse: (BOOL) setInverse;
- (void)remove<$Relationship.name.initialCapitalString$>Object:(NSManagedObject *)value_;
<$if Relationship.isOrdered$>
- (void)insertObject:(NSManagedObject *)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx;
- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx;
- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray *)value atIndexes:(NSIndexSet *)indexes;
- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes;
- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(NSManagedObject *)value;
- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray *)values;
<$endif$>
<$endif$><$endif$><$endforeach do$>
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isToMany$>
- (void) set<$Relationship.name.initialCapitalString$>: (NSManagedObject *) <$Relationship.name$>_ settingInverse: (BOOL) setInverse;
<$endif$><$endif$><$endforeach do$>
@end

@implementation _<$generatedObjectClassName$>

- (instancetype)init
{
	if((self = [super init]))
	{
		<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if Attribute.hasScalarAttributeType$><$if ! Attribute.isOptional$><$if Attribute.defaultValue$>self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$><$Attribute.defaultValue$>];
		<$else$>self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$>0];
		<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
	}
	
	return self;
}

#pragma mark Scalar values
<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if Attribute.hasScalarAttributeType$>
- (<$Attribute.scalarAttributeType$>)<$Attribute.name$>Value
{
	return [self.<$Attribute.name$> <$Attribute.scalarAccessorMethodName$>];
}

- (void)set<$Attribute.name.initialCapitalString$>Value:(<$Attribute.scalarAttributeType$>)value_
{
	self.<$Attribute.name$> = [NSNumber <$Attribute.scalarFactoryMethodName$>value_];
}
<$endif$><$endif$><$endforeach do$>


#pragma mark Dictionary representation

- (void)updateWithDictionaryRepresentation:(NSDictionary *)dictionary objectManager:(id<SBBObjectManagerProtocol>)objectManager
{
    [super updateWithDictionaryRepresentation:dictionary objectManager:objectManager];
    <$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if ! Attribute.userInfo.notInPONSODictionary $>
<$if Attribute.isReadonly$>
    <$if Attribute.hasDateAttributeType$>
    _<$Attribute.name$> = [NSDate dateWithISO8601String:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$else$>
    _<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$endif$>
<$else$>
    <$if Attribute.hasDateAttributeType$>
    self.<$Attribute.name$> = [NSDate dateWithISO8601String:[dictionary objectForKey:@"<$Attribute.name$>"]];
    <$else$>
    self.<$Attribute.name$> = [dictionary objectForKey:@"<$Attribute.name$>"];
    <$endif$>
<$endif$>
    <$endif$><$endif$><$endforeach do$>
<$if userInfo.syntheticKeyComponentPaths.length$><$if userInfo.entityIDKeyPath.length$>
    NSArray *paths = [@"<$userInfo.syntheticKeyComponentPaths$>" componentsSeparatedByString:@","];
    NSString *key = @"";
    for (NSString *path in paths) {
        NSString *value = [dictionary valueForKeyPath:path];
        key = [key stringByAppendingString:value];
    }

    self.<$userInfo.entityIDKeyPath$> = key;
<$endif$><$endif$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
        <$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$><$if Relationship.isToMany$>
    for(id objectRepresentationForDict in [dictionary objectForKey:@"<$Relationship.name$>"])
    {
        <$if TemplateVar.arc$><$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [objectManager objectFromBridgeJSON:objectRepresentationForDict];
        <$else$><$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [[objectManager objectFromBridgeJSON:objectRepresentationForDict] autorelease];
        <$endif$>
        [self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
    }<$else$>NSDictionary *<$Relationship.name$>Dict = [dictionary objectForKey:@"<$Relationship.name$>"];
    if(<$Relationship.name$>Dict != nil)
    {
        <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [objectManager objectFromBridgeJSON:<$Relationship.name$>Dict];
        self.<$Relationship.name$> = <$Relationship.name$>Obj;
        <$if ! TemplateVar.arc$>[<$Relationship.name$>Obj release];<$endif$>
    }<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
}

- (NSDictionary *)dictionaryRepresentationFromObjectManager:(id<SBBObjectManagerProtocol>)objectManager
{
  NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithDictionary:[super dictionaryRepresentationFromObjectManager:objectManager]];
	<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$><$if ! Attribute.userInfo.notInPONSODictionary $>
    <$if Attribute.hasDateAttributeType$>
    [dict setObjectIfNotNil:[self.<$Attribute.name$> ISO8601String] forKey:@"<$Attribute.name$>"];
    <$else$>
    [dict setObjectIfNotNil:self.<$Attribute.name$> forKey:@"<$Attribute.name$>"];
    <$endif$>
	<$endif$><$endif$><$endforeach do$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
    <$if Relationship.isToMany$>if([self.<$Relationship.name$> count] > 0)
	{
		<$if (! Relationship.isTransient) or (Relationship.userInfo.destinationEntityIDKeyPath) $>
		NSMutableArray *<$Relationship.name$>RepresentationsForDictionary = [NSMutableArray arrayWithCapacity:[self.<$Relationship.name$> count]];
		for(<$Relationship.destinationEntity.generatedObjectClassName$> *obj in self.<$Relationship.name$>)
		{
			<$if Relationship.userInfo.destinationEntityIDKeyPath $>[<$Relationship.name$>RepresentationsForDictionary addObject:[obj valueForKeyPath:@"<$Relationship.userInfo.destinationEntityIDKeyPath$>"]];
			<$else$>[<$Relationship.name$>RepresentationsForDictionary addObject:[objectManager bridgeJSONFromObject:obj]];<$endif$>
		}
		[dict setObjectIfNotNil:<$Relationship.name$>RepresentationsForDictionary forKey:@"<$Relationship.name$>"];
		<$endif$>
	}
	<$else$>
	<$if Relationship.userInfo.destinationEntityIDKeyPath $>[dict setObjectIfNotNil:[self.<$Relationship.name$> valueForKeyPath:@"<$Relationship.userInfo.destinationEntityIDKeyPath$>"] forKey:@"<$Relationship.name$>"];
	<$else$><$if ! Relationship.isTransient $>[dict setObjectIfNotNil:[objectManager bridgeJSONFromObject:self.<$Relationship.name$>] forKey:@"<$Relationship.name$>"];
	<$endif$>
	<$endif$>
	<$endif$>
    <$endif$>
	<$endforeach do$>
	return dict;
}

- (void)awakeFromDictionaryRepresentationInit
{
	if(self.sourceDictionaryRepresentation == nil)
		return; // awakeFromDictionaryRepresentationInit has been already executed on this object.
	
	<$foreach Relationship noninheritedRelationshipsInIDKeyPathTopologicalOrder do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if Relationship.userInfo.destinationEntityIDKeyPath $><$if Relationship.isToMany$>NSArray *<$generatedObjectClassName$>_<$Relationship.name$>IDs = [self.sourceDictionaryRepresentation objectForKey:@"<$generatedObjectClassName$>.<$Relationship.name$>"];
	for(id <$generatedObjectClassName$>_<$Relationship.name$>ID in <$generatedObjectClassName$>_<$Relationship.name$>IDs)
	{
		<$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [(_<$generatedObjectClassName$><_<$generatedObjectClassName$>> *)self fetch<$Relationship.destinationEntity.name$>ObjectWithIDFor<$Relationship.name.initialCapitalString$>Relationship:<$generatedObjectClassName$>_<$Relationship.name$>ID];
		if(<$Relationship.name$>Obj != nil)
			[self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
	}
	<$else$>self.<$Relationship.name$> = [(_<$generatedObjectClassName$><_<$generatedObjectClassName$>> *)self fetch<$Relationship.destinationEntity.name$>ObjectWithIDFor<$Relationship.name.initialCapitalString$>Relationship:[self.sourceDictionaryRepresentation objectForKey:@"<$generatedObjectClassName$>.<$Relationship.name$>"]];
	<$if ! Relationship.inverseRelationship.isToMany$>self.<$Relationship.name$>.<$Relationship.inverseRelationship.name$> = (<$generatedObjectClassName$>*)self;
	<$else$>[self.<$Relationship.name$> add<$Relationship.inverseRelationship.name.initialCapitalString$>Object:(<$generatedObjectClassName$>*)self];<$endif$>
	
	<$endif$><$endif$><$endif$><$endforeach do$>


	<$foreach Relationship noninheritedRelationshipsInIDKeyPathTopologicalOrder do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isTransient$><$if Relationship.destinationEntity != Relationship.entity $><$if Relationship.isToMany$>
	for(<$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj in self.<$Relationship.name$>)
	{
		[<$Relationship.name$>Obj awakeFromDictionaryRepresentationInit];
	}
	<$else$>[self.<$Relationship.name$> awakeFromDictionaryRepresentationInit];
	<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
	
	[super awakeFromDictionaryRepresentationInit];
}

#pragma mark Core Data cache

- (NSEntityDescription *)entityForContext:(NSManagedObjectContext *)context
{
    return [NSEntityDescription entityForName:@"<$name$>" inManagedObjectContext:context];
}

- (instancetype)initWithManagedObject:(NSManagedObject *)managedObject objectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
<$if userInfo.encrypted$>
    NSString *password = cacheManager.encryptionKey;
    if (password) {
        NSData *plaintext = [RNDecryptor decryptData:managedObject.ciphertext withPassword:password error:nil];
        NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:plaintext options:0 error:NULL];
        self = [self initWithDictionaryRepresentation:jsonDict objectManager:objectManager];
    } else {
        self = nil;
    }

    return self;
<$else$>
    if (self == [super init]) {
		<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$>
    <$if Attribute.isReadonly$>
        _<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$else$>
        self.<$Attribute.name$> = managedObject.<$Attribute.name$>;
    <$endif$>
		<$endif$><$endforeach do$>
		<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
            <$if ! Relationship.userInfo.destinationEntityIDKeyPath $><$if ! Relationship.isTransient$><$if Relationship.isToMany$>
		for(NSManagedObject *<$Relationship.name$>ManagedObj in managedObject.<$Relationship.name$>)
		{
            <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [[<$Relationship.destinationEntity.generatedObjectClassName$> alloc] initWithManagedObject:<$Relationship.name$>ManagedObj objectManager:objectManager cacheManager:cacheManager];
            if(<$Relationship.name$>Obj != nil)
            {
                [self add<$Relationship.name.initialCapitalString$>Object:<$Relationship.name$>Obj];
            }
		}<$else$>NSManagedObject *<$Relationship.name$>ManagedObj = managedObject.<$Relationship.name$>;
        <$Relationship.destinationEntity.generatedObjectClassName$> *<$Relationship.name$>Obj = [[<$Relationship.destinationEntity.generatedObjectClassName$> alloc] initWithManagedObject:<$Relationship.name$>ManagedObj objectManager:objectManager cacheManager:cacheManager];
        if(<$Relationship.name$>Obj != nil)
        {
          self.<$Relationship.name$> = <$Relationship.name$>Obj;
        }<$endif$><$endif$><$endif$><$endif$><$endforeach do$>
    }

    return self;
<$endif$>
}

- (NSManagedObject *)saveToContext:(NSManagedObjectContext *)cacheContext withObjectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
    NSManagedObject *managedObject = [NSEntityDescription insertNewObjectForEntityForName:@"<$name$>" inManagedObjectContext:cacheContext];
    [self updateManagedObject:managedObject withObjectManager:objectManager cacheManager:cacheManager];

    // Calling code will handle saving these changes to cacheContext.

    return managedObject;
}

- (void)updateManagedObject:(NSManagedObject *)managedObject withObjectManager:(id<SBBObjectManagerProtocol>)objectManager cacheManager:(id<SBBCacheManagerProtocol>)cacheManager
{
    <$if userInfo.encrypted$>
    NSDictionary *jsonDict = [objectManager bridgeJSONFromObject:self];
    NSError *error;
    NSData *plaintext = [NSJSONSerialization dataWithJSONObject:jsonDict options:0 error:&error];
    NSString *password = cacheManager.encryptionKey;
    if (password && !error) {
        NSData *ciphertext = [RNEncryptor encryptData:plaintext withSettings:kRNCryptorAES256Settings password:password error:&error];
        if (!error) {
            managedObject.ciphertext = ciphertext;
        }
    }
    <$else$>
    [super updateManagedObject:managedObject withObjectManager:objectManager cacheManager:cacheManager];
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>NSManagedObjectContext *cacheContext = managedObject.managedObjectContext;<$break$><$endif$><$endforeach do$>
	<$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$>
    managedObject.<$Attribute.name$> = self.<$Attribute.name$>;
	<$endif$><$endforeach do$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>
    <$if Relationship.isToMany$><$if (! Relationship.isTransient) $>if([self.<$Relationship.name$> count] > 0) {
        <$if Relationship.destinationEntity.userInfo.entityIDKeyPath$>for (<$Relationship.destinationEntity.generatedObjectClassName$> *obj in self.<$Relationship.name$>) {
            // see if a managed object for obj is already in the relationship
            BOOL alreadyInRelationship = NO;
            __block NSManagedObject *relMo = nil;
            NSString *keyPath = @"<$Relationship.destinationEntity.userInfo.entityIDKeyPath$>";
            NSString *objectId = obj.<$Relationship.destinationEntity.userInfo.entityIDKeyPath$>;
            while ([objectId isKindOfClass:[NSArray class]]) {
                objectId = ((NSArray *)objectId).firstObject;
            }

            for (NSManagedObject *mo in managedObject.<$Relationship.name$>) {
                if ([[mo valueForKeyPath:keyPath] isEqualToString:objectId]) {
                    relMo = mo;
                    alreadyInRelationship = YES;
                    break;
                }
            }

            // if not, check if one exists but just isn't in the relationship yet
            if (!relMo) {
                NSEntityDescription *relEntity = [NSEntityDescription entityForName:@"<$Relationship.destinationEntity.name$>" inManagedObjectContext:cacheContext];
                NSFetchRequest *request = [[NSFetchRequest alloc] init];
                [request setEntity:relEntity];
                
                NSPredicate *predicate = [NSPredicate predicateWithFormat:@"%@ LIKE %@", keyPath, objectId];
                [request setPredicate:predicate];
                
                NSError *error;
                NSArray *objects = [cacheContext executeFetchRequest:request error:&error];
                if (objects.count) {
                    relMo = [objects firstObject];
                }
            }

            // if still not, create one
            if (!relMo) {
                relMo = [NSEntityDescription insertNewObjectForEntityForName:@"<$Relationship.destinationEntity.name$>" inManagedObjectContext:cacheContext];
            }

            // update it from obj
            [obj updateManagedObject:relMo withObjectManager:objectManager cacheManager:cacheManager];

            // add to relationship if not already in it
            if (!alreadyInRelationship) {
                [managedObject add<$Relationship.name.initialCapitalString$>Object:relMo];
            }
        }<$else$>[managedObject remove<$Relationship.name.initialCapitalString$>Objects];
		for(<$Relationship.destinationEntity.generatedObjectClassName$> *obj in self.<$Relationship.name$>) {
            NSManagedObject *relMo = [obj saveToContext:cacheContext withObjectManager:objectManager cacheManager:cacheManager];
            [managedObject add<$Relationship.name.initialCapitalString$>Object:relMo];
		}<$endif$>
	}<$endif$>
	<$else$>
    <$if ! Relationship.isTransient $><$if Relationship.destinationEntity.userInfo.entityIDKeyPath$>
    <$else$>[cacheContext deleteObject:managedObject.<$Relationship.name$>];
    NSManagedObject *relMo = [self.<$Relationship.name$> saveToContext:cacheContext withObjectManager:objectManager cacheManager:cacheManager];
    [managedObject set<$Relationship.name.initialCapitalString$>:relMo];
	<$endif$><$endif$>
	<$endif$>
    <$endif$>
	<$endforeach do$>
    <$endif$>

    // Calling code will handle saving these changes to cacheContext.
}

#pragma mark Direct access

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if Relationship.isToMany$>
- (void)add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: (BOOL) setInverse
{
    if(self.<$Relationship.name$> == nil)
	{
	    <$if Relationship.isTransient$>
	    CFArrayCallBacks callbacks = {0, NULL, NULL, CFCopyDescription, CFEqual};
      <$if TemplateVar.arc$>
      self.<$Relationship.name$> = (NSMutableArray*)CFArrayCreateMutable(0, 0, &callbacks);
      <$else$>
	    self.<$Relationship.name$> = [(NSMutableArray*) CFArrayCreateMutable(0, 0, &callbacks) autorelease];
      <$endif$>
	    <$else$>
		self.<$Relationship.name$> = [NSMutableArray array];
		<$endif$>
	}
		
	[(NSMutableArray *)self.<$Relationship.name$> addObject:value_];
	<$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
	    [value_ set<$Relationship.inverseRelationship.name.initialCapitalString$>: (<$generatedObjectClassName$>*)self settingInverse: NO];
	}<$endif$><$endif$><$endif$>
}
- (void)add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_
{
    [self add<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: YES];
}

- (void)remove<$Relationship.name.initialCapitalString$>Objects
{
	<$if Relationship.isTransient$>
    CFArrayCallBacks callbacks = {0, NULL, NULL, CFCopyDescription, CFEqual};
      <$if TemplateVar.arc$>
      self.<$Relationship.name$> = (NSMutableArray*)CFArrayCreateMutable(0, 0, &callbacks);
      <$else$>
	    self.<$Relationship.name$> = [(NSMutableArray*) CFArrayCreateMutable(0, 0, &callbacks) autorelease];
      <$endif$>
    <$else$>
	self.<$Relationship.name$> = [NSMutableArray array];
	<$endif$>
}

- (void)remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: (BOOL) setInverse
{
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        [value_ set<$Relationship.inverseRelationship.name.initialCapitalString$>: nil settingInverse: NO];
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> removeObject:value_];
}

- (void)remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_
{
    [self remove<$Relationship.name.initialCapitalString$>Object:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value_ settingInverse: YES];
}
<$if Relationship.isOrdered$>
- (void)insertObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx {
    [self insertObject:value in<$Relationship.name.initialCapitalString$>AtIndex:idx settingInverse:YES];
}

- (void)insertObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value in<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx settingInverse:(BOOL)setInverse {

    [(NSMutableArray *)self.<$Relationship.name$> insertObject:value atIndex:idx];
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    [value set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
}

- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx {
    [self removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:idx settingInverse:YES];
}

- (void)removeObjectFrom<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx settingInverse:(BOOL)setInverse {
    <$Relationship.destinationEntity.generatedObjectClassName$> *object = [self.<$Relationship.name$> objectAtIndex:idx];
    [self remove<$Relationship.name.initialCapitalString$>Object:object settingInverse:YES];
}

- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray *)value atIndexes:(NSIndexSet *)indexes {
    [self insert<$Relationship.name.initialCapitalString$>:value atIndexes:indexes settingInverse:YES];
}

- (void)insert<$Relationship.name.initialCapitalString$>:(NSArray *)value atIndexes:(NSIndexSet *)indexes settingInverse:(BOOL)setInverse {
    [(NSMutableArray *)self.<$Relationship.name$> insertObjects:value atIndexes:indexes];
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in value) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
}

- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes {
    [self remove<$Relationship.name.initialCapitalString$>AtIndexes:indexes settingInverse:YES];
}

- (void)remove<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    NSArray *objectsRemoved = [(NSMutableArray *)self.<$Relationship.name$> objectsAtIndexes:indexes];
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in objectsRemoved) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> removeObjectsAtIndexes:indexes];
}

- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value {
    [self replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:idx withObject:value settingInverse:YES];
}

- (void)replaceObjectIn<$Relationship.name.initialCapitalString$>AtIndex:(NSUInteger)idx withObject:(<$Relationship.destinationEntity.generatedObjectClassName$>*)value settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    <$Relationship.destinationEntity.generatedObjectClassName$>* objectReplaced = [(NSMutableArray *)self.<$Relationship.name$> objectAtIndex:idx];
    [objectReplaced set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
    [value set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> replaceObjectAtIndex:idx withObject:value];
}

- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray *)value {
    [self replace<$Relationship.name.initialCapitalString$>AtIndexes:indexes with<$Relationship.name.initialCapitalString$>:value settingInverse:YES];
}

- (void)replace<$Relationship.name.initialCapitalString$>AtIndexes:(NSIndexSet *)indexes with<$Relationship.name.initialCapitalString$>:(NSArray *)value settingInverse:(BOOL)setInverse {
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if ! Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
    NSArray *objectsReplaced = [(NSMutableArray *)self.<$Relationship.name$> objectsAtIndexes:indexes];
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in objectsReplaced) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:nil settingInverse: NO];
        }
        for (<$Relationship.destinationEntity.generatedObjectClassName$>* object in value) {
            [object set<$Relationship.inverseRelationship.name.initialCapitalString$>:(<$generatedObjectClassName$>*)self settingInverse: NO];
        }
    }<$endif$><$endif$><$endif$>
    [(NSMutableArray *)self.<$Relationship.name$> replaceObjectsAtIndexes:indexes withObjects:value];
}
<$endif$>
<$endif$><$endif$><$endforeach do$>

<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isToMany$>
- (void) set<$Relationship.name.initialCapitalString$>: (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>_ settingInverse: (BOOL) setInverse
{
    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if Relationship.inverseRelationship.isToMany$>if (<$Relationship.name$>_ == nil) {
        [_<$Relationship.name$> remove<$Relationship.inverseRelationship.name.initialCapitalString$>Object: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$else$>if (<$Relationship.name$>_ == nil) {
        [_<$Relationship.name$> set<$Relationship.inverseRelationship.name.initialCapitalString$>: nil settingInverse: NO];
    }
    <$endif$><$endif$><$endif$>
    <$if TemplateVar.arc$>
    _<$Relationship.name$> = <$Relationship.name$>_;
    <$else$>
    <$if Relationship.isTransient$>_<$Relationship.name$> = <$Relationship.name$>_;<$else$>if (_<$Relationship.name$> != <$Relationship.name$>_) {
        [_<$Relationship.name$> release];
        _<$Relationship.name$> = [<$Relationship.name$>_ retain];
    }<$endif$>
    <$endif$>

    <$if Relationship.inverseRelationship$><$if ! Relationship.inverseRelationship.userInfo.notInPONSODictionary $><$if Relationship.inverseRelationship.isToMany$>if (setInverse == YES) {
        [_<$Relationship.name$> add<$Relationship.inverseRelationship.name.initialCapitalString$>Object: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$else$>if (setInverse == YES) {
        [_<$Relationship.name$> set<$Relationship.inverseRelationship.name.initialCapitalString$>: (<$generatedObjectClassName$>*)self settingInverse: NO];
    }<$endif$><$endif$><$endif$>
}

- (void) set<$Relationship.name.initialCapitalString$>: (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>_
{
    [self set<$Relationship.name.initialCapitalString$>: <$Relationship.name$>_ settingInverse: YES];
}

- (<$Relationship.destinationEntity.generatedObjectClassName$>*) <$Relationship.name$>
{
    return _<$Relationship.name$>;
}

<$endif$><$endif$><$endforeach do$>

<$if TemplateVar.arc$>
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $><$if ! Relationship.isToMany$>@synthesize <$Relationship.name$> = _<$Relationship.name$>;<$endif$><$endif$><$endforeach do$>
<$else$>
- (void)dealloc
{
    <$foreach Attribute noninheritedAttributes do$><$if Attribute.hasDefinedAttributeType$>self.<$Attribute.name$> = nil;
    <$endif$><$endforeach do$>
    <$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>self.<$Relationship.name$> = nil;
    <$endif$><$endforeach do$>
    [super dealloc];
}

#pragma mark Synthesizes

<$foreach Attribute noninheritedAttributes do$>@synthesize <$Attribute.name$> = _<$Attribute.name$>;
<$endforeach do$>
<$foreach Relationship noninheritedRelationships do$><$if ! Relationship.userInfo.notInPONSODictionary $>@synthesize <$Relationship.name$> = _<$Relationship.name$>;
<$endif$><$endforeach do$>
<$endif$>

@end
